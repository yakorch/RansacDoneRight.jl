### A Pluto.jl notebook ###
# v0.19.38

using Markdown
using InteractiveUtils

# ╔═╡ 17e83446-d245-11ee-376e-2d07bba971c4
begin
    using Pkg
	NOTEBOOKS_PATH = "src/pluto_notebooks"
	DATA_PATH = "data"  # store generated by notebook data
    @assert endswith(pwd(), NOTEBOOKS_PATH) "Wrong directory!"
	RDR_PATH = "../.."  # path to the RDR project root
    Pkg.activate(RDR_PATH)
	Pkg.instantiate()
	
	import RansacDoneRight as RDR
    md"""
    ### Activating RansacDoneRight environment...
    """
end

# ╔═╡ b48ceec7-c617-4fc0-8bca-92929faf6c50
begin
	using Revise
	using StaticArrays
	using StatsBase
	using LinearAlgebra
	using Combinatorics
	using Plots
	using Statistics
	
	md"""## Package Imports"""
end

# ╔═╡ b59b47e0-3c1e-4298-8bee-c0ec2ecf767c
html"""
<style>
	main {
		margin: 0 auto;
		max-width: 2400px;
		padding-left: max(160px, 10%);
		padding-right: max(160px, 10%);
	}
</style>
"""

# ╔═╡ 169da2fc-586b-4433-abe4-c80781175dbb
"""
	synthetic_labelling_test(I(2), 2. * I(2), 5.99, 3.84, 9.49, 0.4, 1_000, 100_000)

Performs synthetic experiments to verify the viability of probabilistic approach for consensus set labelling and covariance propagation.

- `noise_mᵢ` is the 2x2 covariance matrix of the noise to be applied to the points in the `i`-th image.

- `T₁` is the threshold  statistic for points identity test. Set `0.0` if no check for identity is needed.
- `T₂` is the threshold statistic for point-line incidence test. Set `0.0` if no check for incidence is needed.
- `T₃` is the threshold statistic for consensus set labelling. See `RDR.get_inlier_mask` for more details.

- `outlier_ratio` is the ratio of outliers to be present in all correspondences. For example, if `0.3` is passed, `30%` of correspondences will be corrupted.

- `n_corresps` is the total number of correspondences to be generated.
- `n_runs` is the number of simulations to be run.


The points flip check is not being performed.


"""
function synthetic_labelling_test(noise_m₁, noise_m₂, T₁::Float64, T₂::Float64, T₃::Float64, outlier_ratio::Float64, n_corresps::Integer, n_runs::Integer)
	
	@assert T₁ >= 0. "Can't have a negative threshold statistic"
	@assert T₂ >= 0. "Can't have a negative threshold statistic"
	@assert 0. <= outlier_ratio < 1. "An ivalid outlier ratio"
	
	image_bounds = [800., 1200.]

	n_outliers = Integer(round(n_corresps * outlier_ratio)) + 1  # + 1 to not introduce errors with 1:0 UnitRange. 
	
	outlier_indices = 1:n_outliers

	confusion_matrix_labelling = zeros(2, 2)
	
	apt_noise_m₁ = 1. * noise_m₁
	apt_noise_m₂ = 1. * noise_m₂

	inlier_statistics = Float64[]
	avg_residual_variance = Float64[]
	homography_traces = Float64[]

	inlier_indices = (n_outliers+1):n_corresps

	for i in 1:n_runs
		certain_minimal_set = RDR.generate_random_minimal_set(image_bounds)
		certain_H = RDR.compute_homography(certain_minimal_set)

		corresps = RDR.generate_k_random_correspondences(n_corresps, certain_H, image_bounds)
		RDR.populate_outliers!((@view corresps[outlier_indices]), image_bounds)

		noised_corresps = RDR.add_noise(corresps, apt_noise_m₁, apt_noise_m₂, true)

		minimal_set_indices::MVector{4, Integer} = sample(inlier_indices, 4, replace=false)
		non_minimal_set_indices = setdiff(1:n_corresps, minimal_set_indices)

		minimal_set::MVector{4, RDR.Correspondence{Float64}} = @view noised_corresps[minimal_set_indices]

		collinearity_checks_passed = RDR.test_minimal_set_fully(minimal_set, T₁, T₂, true)

		if !collinearity_checks_passed
			continue
		end

		uncertain_homography = RDR.compute_uncertain_homography(minimal_set)
		RDR.swap_points_in_correspondence!.(minimal_set)
		backward_uncertain_homography = RDR.compute_uncertain_homography(minimal_set)

		uncertain_residuals = RDR.compute_uncertain_residuals(uncertain_homography, @view noised_corresps[non_minimal_set_indices])
		RDR.swap_points_in_correspondence!.(@view noised_corresps[non_minimal_set_indices])
		backward_uncertain_residuals = RDR.compute_uncertain_residuals(backward_uncertain_homography, @view noised_corresps[non_minimal_set_indices])

		statistics = RDR.compute_inlier_test_statistic.(uncertain_residuals)
		backward_statistics = RDR.compute_inlier_test_statistic.(backward_uncertain_residuals)
		
		predicted_inlier_mask = @. (statistics < T₃) # && (backward_statistics < T₃)

		for j in 1:(n_corresps-4)
			confusion_matrix_labelling[(j > n_outliers) + 1, predicted_inlier_mask[j] + 1] += 1
		end

		push!(inlier_statistics, sum(@view statistics[(n_outliers+1):(n_corresps-4)]) / (n_corresps - n_outliers - 4) + sum(@view backward_statistics[(n_outliers+1):(n_corresps-4)]) / (n_corresps - n_outliers - 4))

		avg_var = 0
		for j in (n_outliers+1):(n_corresps-4)
			avg_var += abs(det(uncertain_residuals[j].covariance_matrix[1:2, 1:2])) ^ 0.5
			avg_var += abs(det(backward_uncertain_residuals[j].covariance_matrix[1:2, 1:2])) ^ 0.5

			# push!(avg_residual_variance, avg_var)
			# push!(inlier_statistics, statistics[j])
		end

		avg_var /= 2 * (n_corresps - n_outliers - 4)
		push!(avg_residual_variance, avg_var)
		
		push!(homography_traces, abs(det(RDR.normalize_onto_unit_sphere(uncertain_homography).Σₕ))^(1/9))

	end
	return confusion_matrix_labelling, inlier_statistics, homography_traces
end

# ╔═╡ 26827270-dd23-46f5-a72e-3462d36f65ae
begin
	total_runs = 5_000

	conf_m_labelling, avg_trace_cov_m_of_residuals, homography_traces = synthetic_labelling_test(1. * I(2), 1. * I(2), 9.21, 6.63, 9.21, 0.3, 1000, total_runs)

	conf_m_labelling_percents = conf_m_labelling
	for j in 1:2
		conf_m_labelling_percents[j, :] /= (sum(conf_m_labelling_percents[j, :]) / 100)
	end

	md"""
	##### Choose the simulation parameters here.
	"""
end

# ╔═╡ dfb98830-98d4-4876-bdaf-a25fa43bebd4
md"""
#### Confusion matrix for labelling.
- 1st row: the correspondence was actually an outlier
- 2nd row: the correspondence was actually an inlier


- 1st column: correspondence predicted to be an outlier
- 2nd column: correspondence predicted to be an inlier

"""

# ╔═╡ 3dcf98a5-d540-47fa-9116-738221fbfb08
conf_m_labelling_percents

# ╔═╡ ac093750-2b71-447b-9e6a-804ae350c2eb
md"""
#### Correlation between the consensus test statistic and avg. trace of residuals' cov. matrix:

$(cor(avg_trace_cov_m_of_residuals, homography_traces))
"""

# ╔═╡ Cell order:
# ╟─b59b47e0-3c1e-4298-8bee-c0ec2ecf767c
# ╟─17e83446-d245-11ee-376e-2d07bba971c4
# ╟─b48ceec7-c617-4fc0-8bca-92929faf6c50
# ╠═169da2fc-586b-4433-abe4-c80781175dbb
# ╠═26827270-dd23-46f5-a72e-3462d36f65ae
# ╟─dfb98830-98d4-4876-bdaf-a25fa43bebd4
# ╠═3dcf98a5-d540-47fa-9116-738221fbfb08
# ╟─ac093750-2b71-447b-9e6a-804ae350c2eb

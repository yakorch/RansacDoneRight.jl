### A Pluto.jl notebook ###
# v0.19.40

using Markdown
using InteractiveUtils

# ╔═╡ b407fd34-d0a6-11ee-3345-fd33e806845d
begin
    using Pkg
    NOTEBOOKS_PATH = "src/pluto_notebooks"
    DATA_PATH = "data"  # store generated by notebook data
    @assert endswith(pwd(), NOTEBOOKS_PATH) "Wrong directory!"
    RDR_PATH = "../../.."  # path to the RDR project root
    Pkg.activate(RDR_PATH)

    import RansacDoneRight as RDR
    md"""
    ### Activating RansacDoneRight environment...
    """
end

# ╔═╡ dffabbf8-eb57-4853-b195-f9b8ae858ed8
begin
    using Revise
    using StaticArrays
    using LinearAlgebra
    using Plots
    using KernelDensity
    using StatsBase
    using Statistics
    using StatsPlots
end

# ╔═╡ 49761944-0e6d-4621-9d2f-26f41b8f326c
html"""
<style>
	main {
		margin: 0 auto;
		max-width: 2000px;
    	padding-left: max(160px, 15%);
    	padding-right: max(160px, 15%);
	}
</style>
"""

# ╔═╡ decf60fd-02f3-41c9-83d1-b0f5168d5751
take_log_10(data) = log10.(filter(x -> x > 0, data))

# ╔═╡ 3129c8ed-a339-4171-95fe-8cb9bd78525a
"""
- `solver` takes in the vector of correspondences and outputs `H` -- a `3 × 3` matrix.
- `n_runs` is the number of iterations for a numerical stability test.

The norms of the residuals are returned.
"""
function test_numerical_stability(solver::Function, n_runs)
    residuals = Vector{Float64}(undef, 4 * n_runs)

    counter = 1
    for _ in 1:n_runs
        minimal_set::MVector{4,RDR.Correspondence{Float64}} = RDR.generate_random_minimal_set()

        Ĥ = solver(minimal_set)
        lu_Ĥ = lu(Ĥ)

        for j in 1:4
            corresp = minimal_set[j]

            r::MVector{4,Float64} = RDR.compute_reprojection_residual(Ĥ, lu_Ĥ, corresp)

            residuals[counter] = sqrt(r[1] * r[1] + r[2] * r[2] + r[3] * r[3] + r[4] * r[4])
            counter += 1
        end
    end
    residuals
end

# ╔═╡ 4ed7e102-80f3-4c58-ba85-4ddd4016f3ef
"""
plots smoothed histogram.
"""
function plot_smoothed_histogram(values::V, label="Smoothed Density", modify=false) where {V<:AbstractVector{Float64}}
    hist = fit(Histogram, values, closed=:left)
    kde = KernelDensity.kde(values)

    plot_func = modify ? Plots.plot! : Plots.plot
	plot_func(kde.x, kde.density, label=label, linewidth=2, size=(800, 600))
end

# ╔═╡ d7a9f07e-d85a-428d-856a-91f5f03eb594
begin
    solver_errors = test_numerical_stability(RDR.compute_homography, 100_000)
	plot_num_stability = plot_smoothed_histogram(log10.(filter(x -> x > 0, solver_errors))
    )
    xlabel!("Log10 Error (Residual)")
    ylabel!("Empirical Density")
    title!("Numerical Stability Experiment. Errors' Empirical Density")
    plot_num_stability
end

# ╔═╡ db084605-cf6a-46a5-9efc-e32d2dd6ec7f
"""
- `solver` takes in the vector of correspondences and outputs `H` -- a `3 × 3` matrix.
- `n_runs` is the number of iterations for a numerical stability test.

- `σ₁` is the std. dev. of the noise for the points in the first image.
- `σ₂` is the std. dev. of the noise for the points in the second image.

The norms of the residuals are returned.
"""
function test_numerical_sensitivity(solver::Function, σ₁, σ₂, n_minimal_sets, runs_for_min_set)
    residuals = Vector{Float64}(undef, 4 * n_minimal_sets * runs_for_min_set)

    noise_m₁ = [σ₁^2 0; 0 σ₁^2]
    noise_m₂ = [σ₂^2 0; 0 σ₂^2]

    counter = 1

    for _ in 1:n_minimal_sets
        minimal_set::MVector{4,RDR.Correspondence{Float64}} = RDR.generate_random_minimal_set()

        for k in 1:runs_for_min_set
            noised = RDR.add_noise(minimal_set, noise_m₁, noise_m₂, true)

            Ĥ = solver(noised)
            lu_Ĥ = lu(Ĥ)

            for j in 1:4
                corresp = minimal_set[j]

                r::MVector{4,Float64} = RDR.compute_reprojection_residual(Ĥ, lu_Ĥ, corresp)

                residuals[counter] = sqrt(r[1] * r[1] + r[2] * r[2] + r[3] * r[3] + r[4] * r[4])
                counter += 1
            end
        end
    end
    residuals
end

# ╔═╡ b5b4c13b-6426-4a66-9cc0-ed4503b74c6d
begin
	runs = Integer(2e5)

	H_solvers = [RDR.compute_homography, RDR.compute_homography_h₉_equals_1, RDR.compute_homography_svd]
	solver_labels = ["Our Method", "h₉=1", "SVD"]

	numerical_stability_wrapper(H_solver) = test_numerical_stability(H_solver, runs)

	all_stability_errors_logged = @. take_log_10(numerical_stability_wrapper(H_solvers))

	p = Plots.plot(title="Distributions of errors | Log10 | σ=0", xlabel="||r||₂ values", ylabel="Density", legend=:topright, xticks=10)

	for (errors, solver_label) in zip(all_stability_errors_logged, solver_labels)
		kde_result = kde(errors)
		Plots.plot!(p, kde_result.x, kde_result.density, label=solver_label, linewidth=2)
	end
	p
end

# ╔═╡ cb7028e3-3222-4fe8-ad3b-492c64ef497b
begin
	sigmas = [0.001, 0.01, 0.1, 0.25, 1.0, 2.5]
	n_runs = Integer(1e5)

	using DataFrames
	using CSV
	
	df = DataFrame(Solver_Type = String[], Sigma = Float64[], Results = Float64[])

	plots = []

	for (solver, label) in zip(H_solvers, solver_labels)
		all_errors = []
	    for sigma in sigmas
	        errors = test_numerical_sensitivity(solver, sigma, sigma, n_runs, 1)
			push!(all_errors, errors)

			log_10_errors = take_log_10(errors)
			for error in log_10_errors
	            push!(df, (Solver_Type = label, Sigma = sigma, Results = error))
	        end
	    end
		
		sens_p = Plots.plot(title="Dist. of errors wrt. σ | Log10 | " * label, xlabel="||r||₂", ylabel="Density", legend=:topright, xticks=10)

		for (errors, sigma) in zip(all_errors, sigmas)
			kde_result = kde(take_log_10(errors))
			Plots.plot!(sens_p, kde_result.x, kde_result.density, label="σ = $(sigma)", linewidth=2)
		end

		push!(plots, sens_p)
	end
	CSV.write(DATA_PATH * "/numerical_sensitivity_results.csv", df)

	plots
	
end

# ╔═╡ ac313f24-54a5-4f7d-97c2-5bec80e799f6


# ╔═╡ 9de8dc00-1e28-40b4-aea7-1a0023067a14


# ╔═╡ Cell order:
# ╟─49761944-0e6d-4621-9d2f-26f41b8f326c
# ╠═b407fd34-d0a6-11ee-3345-fd33e806845d
# ╠═dffabbf8-eb57-4853-b195-f9b8ae858ed8
# ╠═decf60fd-02f3-41c9-83d1-b0f5168d5751
# ╟─3129c8ed-a339-4171-95fe-8cb9bd78525a
# ╟─4ed7e102-80f3-4c58-ba85-4ddd4016f3ef
# ╠═d7a9f07e-d85a-428d-856a-91f5f03eb594
# ╟─db084605-cf6a-46a5-9efc-e32d2dd6ec7f
# ╠═b5b4c13b-6426-4a66-9cc0-ed4503b74c6d
# ╠═ac313f24-54a5-4f7d-97c2-5bec80e799f6
# ╠═cb7028e3-3222-4fe8-ad3b-492c64ef497b
# ╠═9de8dc00-1e28-40b4-aea7-1a0023067a14
